src/index.tsx:export type {
src/index.tsx:export type {ConversationMessage, GPTConfiguration} from './types/gpt'
src/App.tsx:export default App
src/hero.ts:export default heroui() as unknown as Plugin | Plugin[]
src/types/gpt.ts:export const GPTCapabilitiesSchema = z.object({
src/types/gpt.ts:export type GPTCapabilities = z.infer<typeof GPTCapabilitiesSchema>
src/types/gpt.ts:export const LocalFileSchema = z.object({
src/types/gpt.ts:export type LocalFile = z.infer<typeof LocalFileSchema>
src/types/gpt.ts:export const MCPToolSchema = z.object({
src/types/gpt.ts:export type MCPTool = z.infer<typeof MCPToolSchema>
src/types/gpt.ts:export const VectorStoreSchema = z.object({
src/types/gpt.ts:export type VectorStore = z.infer<typeof VectorStoreSchema>
src/types/gpt.ts:export const GPTKnowledgeSchema = z.object({
src/types/gpt.ts:export const GPTMCPConfigSchema = z.object({
src/types/gpt.ts:export type GPTMCPConfig = z.infer<typeof GPTMCPConfigSchema>
src/types/gpt.ts:export const GPTConfigurationSchema = z.object({
src/types/gpt.ts:export type GPTConfiguration = z.infer<typeof GPTConfigurationSchema>
src/types/gpt.ts:export const ConversationMessageMetadataSchema = z.object({
src/types/gpt.ts:export type ConversationMessageMetadata = z.infer<typeof ConversationMessageMetadataSchema>
src/types/gpt.ts:export const ConversationMessageSchema = z.object({
src/types/gpt.ts:export type ConversationMessage = z.infer<typeof ConversationMessageSchema>
src/types/gpt.ts:export const ConversationSchema = z.object({
src/types/gpt.ts:export type Conversation = z.infer<typeof ConversationSchema>
src/types/ollama.ts:export const OllamaConfigSchema = z.object({
src/types/ollama.ts:export const OllamaModelInfoSchema = z.object({
src/types/ollama.ts:export const OllamaModelDetailsSchema = z.object({
src/types/ollama.ts:export const OllamaChatMessageSchema = z.object({
src/types/ollama.ts:export const OllamaThinkingConfigSchema = z.object({
src/types/ollama.ts:export const OllamaChatRequestSchema = z.object({
src/types/ollama.ts:export const OllamaChatResponseSchema = z.object({
src/types/ollama.ts:export const OllamaStreamChunkSchema = z.object({
src/types/ollama.ts:export const OllamaPullProgressSchema = z.object({
src/types/ollama.ts:export const OllamaModelsResponseSchema = z.object({
src/types/ollama.ts:export const OllamaErrorResponseSchema = z.object({
src/types/ollama.ts:export type OllamaConfig = z.infer<typeof OllamaConfigSchema>
src/types/ollama.ts:export type OllamaModelInfo = z.infer<typeof OllamaModelInfoSchema>
src/types/ollama.ts:export type OllamaModelDetails = z.infer<typeof OllamaModelDetailsSchema>
src/types/ollama.ts:export type OllamaChatMessage = z.infer<typeof OllamaChatMessageSchema>
src/types/ollama.ts:export type OllamaChatRequest = z.infer<typeof OllamaChatRequestSchema>
src/types/ollama.ts:export type OllamaChatResponse = z.infer<typeof OllamaChatResponseSchema>
src/types/ollama.ts:export type OllamaStreamChunk = z.infer<typeof OllamaStreamChunkSchema>
src/types/ollama.ts:export type OllamaThinkingConfig = z.infer<typeof OllamaThinkingConfigSchema>
src/types/ollama.ts:export type OllamaPullProgress = z.infer<typeof OllamaPullProgressSchema>
src/types/ollama.ts:export type OllamaModelsResponse = z.infer<typeof OllamaModelsResponseSchema>
src/types/ollama.ts:export type OllamaErrorResponse = z.infer<typeof OllamaErrorResponseSchema>
src/types/ollama.ts:export interface OllamaThinkingResponse {
src/types/ollama.ts:export const OllamaConnectionStatusSchema = z.enum(['unknown', 'checking', 'connected', 'disconnected', 'cors_error'])
src/types/ollama.ts:export type OllamaConnectionStatus = z.infer<typeof OllamaConnectionStatusSchema>
src/types/ollama.ts:export interface OllamaConnectionInfo {
src/types/ollama.ts:export const VISION_MODEL_PREFIXES = [
src/types/ollama.ts:export const REASONING_MODEL_PREFIXES = ['deepseek-r1', 'qwen3', 'qwq'] as const
src/types/ollama.ts:export function supportsVision(modelName: string): boolean {
src/types/ollama.ts:export function supportsThinking(modelName: string): boolean {
src/types/ollama.ts:export function parseThinkingContent(content: string): OllamaThinkingResponse {
src/types/ollama.ts:export function formatModelSize(bytes: number): string {
src/types/ollama.ts:export function estimateVRAMRequired(parameterBillions: number, quantization: string): number {
src/types/knowledge.ts:export const KnowledgeFileCategorySchema = z.enum(['document', 'code', 'data', 'other'])
src/types/knowledge.ts:export type KnowledgeFileCategory = z.infer<typeof KnowledgeFileCategorySchema>
src/types/knowledge.ts:export const ExtractionStatusSchema = z.enum(['pending', 'processing', 'completed', 'failed', 'unsupported'])
src/types/knowledge.ts:export type ExtractionStatus = z.infer<typeof ExtractionStatusSchema>
src/types/knowledge.ts:export const KnowledgeFileDBSchema = z.object({
src/types/knowledge.ts:export type KnowledgeFileDB = z.infer<typeof KnowledgeFileDBSchema>
src/types/knowledge.ts:export const CachedURLStatusSchema = z.enum(['pending', 'fetching', 'ready', 'failed'])
src/types/knowledge.ts:export type CachedURLStatus = z.infer<typeof CachedURLStatusSchema>
src/types/knowledge.ts:export const CachedURLDBSchema = z.object({
src/types/knowledge.ts:export type CachedURLDB = z.infer<typeof CachedURLDBSchema>
src/types/knowledge.ts:export const TextSnippetDBSchema = z.object({
src/types/knowledge.ts:export type TextSnippetDB = z.infer<typeof TextSnippetDBSchema>
src/types/knowledge.ts:export const CreateSnippetInputSchema = z.object({
src/types/knowledge.ts:export type CreateSnippetInput = z.infer<typeof CreateSnippetInputSchema>
src/types/knowledge.ts:export const UpdateSnippetInputSchema = z.object({
src/types/knowledge.ts:export type UpdateSnippetInput = z.infer<typeof UpdateSnippetInputSchema>
src/types/knowledge.ts:export const SearchResultSchema = z.object({
src/types/knowledge.ts:export type SearchResult = z.infer<typeof SearchResultSchema>
src/types/knowledge.ts:export const KnowledgeSummarySchema = z.object({
src/types/knowledge.ts:export type KnowledgeSummary = z.infer<typeof KnowledgeSummarySchema>
src/types/knowledge.ts:export const ExtractionOptionsSchema = z.object({
src/types/knowledge.ts:export type ExtractionOptions = z.infer<typeof ExtractionOptionsSchema>
src/types/knowledge.ts:export const KNOWLEDGE_CONSTANTS = {
src/types/anthropic.ts:export const AnthropicModelDatedSchema = z.enum([
src/types/anthropic.ts:export const AnthropicModelAliasSchema = z.enum(['claude-opus-4-5', 'claude-sonnet-4-5', 'claude-haiku-4-5'])
src/types/anthropic.ts:export const AnthropicModelSchema = z.union([AnthropicModelDatedSchema, AnthropicModelAliasSchema])
src/types/anthropic.ts:export const AnthropicModelCapabilitiesSchema = z.object({
src/types/anthropic.ts:export const AnthropicTextContentSchema = z.object({
src/types/anthropic.ts:export const AnthropicImageContentSchema = z.object({
src/types/anthropic.ts:export const AnthropicToolUseContentSchema = z.object({
src/types/anthropic.ts:export const AnthropicToolResultContentSchema = z.object({
src/types/anthropic.ts:export const AnthropicThinkingContentSchema = z.object({
src/types/anthropic.ts:export const AnthropicRedactedThinkingContentSchema = z.object({
src/types/anthropic.ts:export const AnthropicContentBlockSchema = z.union([
src/types/anthropic.ts:export const AnthropicMessageSchema = z.object({
src/types/anthropic.ts:export const AnthropicToolSchema = z.object({
src/types/anthropic.ts:export const AnthropicToolChoiceSchema = z.union([
src/types/anthropic.ts:export const AnthropicExtendedThinkingConfigSchema = z.object({
src/types/anthropic.ts:export const AnthropicRequestSchema = z.object({
src/types/anthropic.ts:export const AnthropicUsageSchema = z.object({
src/types/anthropic.ts:export const AnthropicStopReasonSchema = z.enum(['end_turn', 'max_tokens', 'stop_sequence', 'tool_use'])
src/types/anthropic.ts:export const AnthropicResponseSchema = z.object({
src/types/anthropic.ts:export const AnthropicMessageStartEventSchema = z.object({
src/types/anthropic.ts:export const AnthropicContentBlockStartEventSchema = z.object({
src/types/anthropic.ts:export const AnthropicTextDeltaSchema = z.object({
src/types/anthropic.ts:export const AnthropicThinkingDeltaSchema = z.object({
src/types/anthropic.ts:export const AnthropicInputJsonDeltaSchema = z.object({
src/types/anthropic.ts:export const AnthropicContentBlockDeltaEventSchema = z.object({
src/types/anthropic.ts:export const AnthropicContentBlockStopEventSchema = z.object({
src/types/anthropic.ts:export const AnthropicMessageDeltaEventSchema = z.object({
src/types/anthropic.ts:export const AnthropicMessageStopEventSchema = z.object({
src/types/anthropic.ts:export const AnthropicPingEventSchema = z.object({
src/types/anthropic.ts:export const AnthropicErrorEventSchema = z.object({
src/types/anthropic.ts:export const AnthropicStreamEventSchema = z.discriminatedUnion('type', [
src/types/anthropic.ts:export const AnthropicAPIErrorSchema = z.object({
src/types/anthropic.ts:export const AnthropicRateLimitInfoSchema = z.object({
src/types/anthropic.ts:export type AnthropicModel = z.infer<typeof AnthropicModelSchema>
src/types/anthropic.ts:export type AnthropicModelDated = z.infer<typeof AnthropicModelDatedSchema>
src/types/anthropic.ts:export type AnthropicModelAlias = z.infer<typeof AnthropicModelAliasSchema>
src/types/anthropic.ts:export type AnthropicModelCapabilities = z.infer<typeof AnthropicModelCapabilitiesSchema>
src/types/anthropic.ts:export type AnthropicContentBlock = z.infer<typeof AnthropicContentBlockSchema>
src/types/anthropic.ts:export type AnthropicTextContent = z.infer<typeof AnthropicTextContentSchema>
src/types/anthropic.ts:export type AnthropicImageContent = z.infer<typeof AnthropicImageContentSchema>
src/types/anthropic.ts:export type AnthropicToolUseContent = z.infer<typeof AnthropicToolUseContentSchema>
src/types/anthropic.ts:export type AnthropicToolResultContent = z.infer<typeof AnthropicToolResultContentSchema>
src/types/anthropic.ts:export type AnthropicThinkingContent = z.infer<typeof AnthropicThinkingContentSchema>
src/types/anthropic.ts:export type AnthropicMessage = z.infer<typeof AnthropicMessageSchema>
src/types/anthropic.ts:export type AnthropicTool = z.infer<typeof AnthropicToolSchema>
src/types/anthropic.ts:export type AnthropicToolChoice = z.infer<typeof AnthropicToolChoiceSchema>
src/types/anthropic.ts:export type AnthropicExtendedThinkingConfig = z.infer<typeof AnthropicExtendedThinkingConfigSchema>
src/types/anthropic.ts:export type AnthropicRequest = z.infer<typeof AnthropicRequestSchema>
src/types/anthropic.ts:export type AnthropicResponse = z.infer<typeof AnthropicResponseSchema>
src/types/anthropic.ts:export type AnthropicUsage = z.infer<typeof AnthropicUsageSchema>
src/types/anthropic.ts:export type AnthropicStopReason = z.infer<typeof AnthropicStopReasonSchema>
src/types/anthropic.ts:export type AnthropicStreamEvent = z.infer<typeof AnthropicStreamEventSchema>
src/types/anthropic.ts:export type AnthropicAPIError = z.infer<typeof AnthropicAPIErrorSchema>
src/types/anthropic.ts:export type AnthropicRateLimitInfo = z.infer<typeof AnthropicRateLimitInfoSchema>
src/types/anthropic.ts:export const ANTHROPIC_MODEL_ALIASES: Record<AnthropicModelAlias, AnthropicModelDated> = {
src/types/anthropic.ts:export const ANTHROPIC_MODEL_CAPABILITIES: Record<AnthropicModelDated, AnthropicModelCapabilities> = {
src/types/anthropic.ts:export function resolveAnthropicModel(model: AnthropicModel): AnthropicModelDated {
src/types/anthropic.ts:export function getAnthropicModelCapabilities(model: AnthropicModel): AnthropicModelCapabilities | undefined {
src/types/agent.ts:export interface CacheConfig {
src/types/agent.ts:export const AgentConfigSchema = z.object({
src/types/agent.ts:export type AgentConfig = z.infer<typeof AgentConfigSchema>
src/types/agent.ts:export interface AgentMemory {
src/types/agent.ts:export interface AgentState {
src/types/agent.ts:export interface AgentResponse {
src/types/agent.ts:export interface AgentCapabilities {
src/types/agent.ts:export interface Agent {
src/types/agent.ts:export interface ToolConfig {
src/types/mcp.ts:export const MCP_PROTOCOL_VERSION = '2025-11-25'
src/types/mcp.ts:export const MCPTransportTypeSchema = z.enum(['stdio', 'streamable-http'])
src/types/mcp.ts:export type MCPTransportType = z.infer<typeof MCPTransportTypeSchema>
src/types/mcp.ts:export const MCPIconSchema = z.object({
src/types/mcp.ts:export type MCPIcon = z.infer<typeof MCPIconSchema>
src/types/mcp.ts:export const MCPOAuthConfigSchema = z.object({
src/types/mcp.ts:export type MCPOAuthConfig = z.infer<typeof MCPOAuthConfigSchema>
src/types/mcp.ts:export const MCPAuthenticationSchema = z.discriminatedUnion('type', [
src/types/mcp.ts:export type MCPAuthentication = z.infer<typeof MCPAuthenticationSchema>
src/types/mcp.ts:export const MCPServerConfigSchema = z.object({
src/types/mcp.ts:export type MCPServerConfig = z.infer<typeof MCPServerConfigSchema>
src/types/mcp.ts:export const MCPToolCallStatusSchema = z.enum(['pending', 'running', 'success', 'error', 'cancelled'])
src/types/mcp.ts:export type MCPToolCallStatus = z.infer<typeof MCPToolCallStatusSchema>
src/types/mcp.ts:export const MCPToolCallSchema = z.object({
src/types/mcp.ts:export type MCPToolCall = z.infer<typeof MCPToolCallSchema>
src/types/mcp.ts:export const MCPTaskStatusSchema = z.enum(['running', 'completed', 'failed', 'cancelled'])
src/types/mcp.ts:export type MCPTaskStatus = z.infer<typeof MCPTaskStatusSchema>
src/types/mcp.ts:export const MCPTaskSchema = z.object({
src/types/mcp.ts:export type MCPTask = z.infer<typeof MCPTaskSchema>
src/types/mcp.ts:export const MCPOAuthTokensSchema = z.object({
src/types/mcp.ts:export type MCPOAuthTokens = z.infer<typeof MCPOAuthTokensSchema>
src/types/mcp.ts:export const MCPConnectionStatusSchema = z.enum(['disconnected', 'connecting', 'connected', 'error'])
src/types/mcp.ts:export type MCPConnectionStatus = z.infer<typeof MCPConnectionStatusSchema>
src/types/mcp.ts:export const MCPToolApprovalModeSchema = z.enum(['auto', 'always-ask', 'trusted-only'])
src/types/mcp.ts:export type MCPToolApprovalMode = z.infer<typeof MCPToolApprovalModeSchema>
src/types/mcp.ts:export const GPTMCPConfigSchema = z.object({
src/types/mcp.ts:export type GPTMCPConfig = z.infer<typeof GPTMCPConfigSchema>
src/types/mcp.ts:export interface MCPServerConfigDB {
src/types/mcp.ts:export interface MCPToolCallDB {
src/types/mcp.ts:export interface MCPTaskDB {
src/types/mcp.ts:export interface MCPOAuthTokensDB {
src/types/mcp.ts:export interface MCPDiscoveredCapabilities {
src/types/mcp.ts:export interface MCPDiscoveredTool {
src/types/mcp.ts:export interface MCPDiscoveredResource {
src/types/mcp.ts:export interface MCPDiscoveredPrompt {
src/types/export-import.ts:export const ExportVersionSchema = z.enum(['1.0', '1.1'])
src/types/export-import.ts:export type ExportVersion = z.infer<typeof ExportVersionSchema>
src/types/export-import.ts:export const ExportMetadataSchema = z.object({
src/types/export-import.ts:export type ExportMetadata = z.infer<typeof ExportMetadataSchema>
src/types/export-import.ts:export const KnowledgeFileExportSchema = z.object({
src/types/export-import.ts:export type KnowledgeFileExport = z.infer<typeof KnowledgeFileExportSchema>
src/types/export-import.ts:export const CachedURLExportSchema = z.object({
src/types/export-import.ts:export type CachedURLExport = z.infer<typeof CachedURLExportSchema>
src/types/export-import.ts:export const KnowledgeSnippetSchema = z.object({
src/types/export-import.ts:export type KnowledgeSnippet = z.infer<typeof KnowledgeSnippetSchema>
src/types/export-import.ts:export const CapabilitiesExportSchema = z.object({
src/types/export-import.ts:export type CapabilitiesExport = z.infer<typeof CapabilitiesExportSchema>
src/types/export-import.ts:export const ToolExportSchema = z.object({
src/types/export-import.ts:export type ToolExport = z.infer<typeof ToolExportSchema>
src/types/export-import.ts:export const ModelSettingsExportSchema = z.object({
src/types/export-import.ts:export type ModelSettingsExport = z.infer<typeof ModelSettingsExportSchema>
src/types/export-import.ts:export const GPTDataExportSchema = z.object({
src/types/export-import.ts:export type GPTDataExport = z.infer<typeof GPTDataExportSchema>
src/types/export-import.ts:export const KnowledgeExportSchema = z.object({
src/types/export-import.ts:export type KnowledgeExport = z.infer<typeof KnowledgeExportSchema>
src/types/export-import.ts:export const VersionHistoryEntrySchema = z.object({
src/types/export-import.ts:export type VersionHistoryEntry = z.infer<typeof VersionHistoryEntrySchema>
src/types/export-import.ts:export const GPTExportSchema = z.object({
src/types/export-import.ts:export type GPTExport = z.infer<typeof GPTExportSchema>
src/types/export-import.ts:export const MessageExportSchema = z.object({
src/types/export-import.ts:export type MessageExport = z.infer<typeof MessageExportSchema>
src/types/export-import.ts:export const ConversationDataExportSchema = z.object({
src/types/export-import.ts:export type ConversationDataExport = z.infer<typeof ConversationDataExportSchema>
src/types/export-import.ts:export const ConversationExportSchema = z.object({
src/types/export-import.ts:export type ConversationExport = z.infer<typeof ConversationExportSchema>
src/types/export-import.ts:export const FolderExportSchema = z.object({
src/types/export-import.ts:export type FolderExport = z.infer<typeof FolderExportSchema>
src/types/export-import.ts:export const BulkExportManifestSchema = z.object({
src/types/export-import.ts:export type BulkExportManifest = z.infer<typeof BulkExportManifestSchema>
src/types/export-import.ts:export const FullBackupSchema = z.object({
src/types/export-import.ts:export type FullBackup = z.infer<typeof FullBackupSchema>
src/types/export-import.ts:export const ConflictResolutionSchema = z.enum(['skip', 'overwrite', 'rename'])
src/types/export-import.ts:export type ConflictResolution = z.infer<typeof ConflictResolutionSchema>
src/types/export-import.ts:export const ImportResultSchema = z.object({
src/types/export-import.ts:export type ImportResult = z.infer<typeof ImportResultSchema>
src/types/export-import.ts:export const ImportValidationSchema = z.object({
src/types/export-import.ts:export type ImportValidation = z.infer<typeof ImportValidationSchema>
src/types/export-import.ts:export const ImportPreviewItemSchema = z.object({
src/types/export-import.ts:export type ImportPreviewItem = z.infer<typeof ImportPreviewItemSchema>
src/types/export-import.ts:export const ImportPreviewSchema = z.object({
src/types/export-import.ts:export type ImportPreview = z.infer<typeof ImportPreviewSchema>
src/types/export-import.ts:export interface GPTExportOptions {
src/types/export-import.ts:export interface BulkExportOptions extends GPTExportOptions {
src/types/export-import.ts:export type ExportFormat = 'json' | 'markdown' | 'pdf'
src/types/export-import.ts:export interface RestoreOptions {
src/types/export-import.ts:export type ExportProgressCallback = (progress: {
src/types/export-import.ts:export type ImportProgressCallback = (progress: {
src/types/export-import.ts:export const APP_VERSION = '1.0.0'
src/types/export-import.ts:export const CURRENT_EXPORT_VERSION: ExportVersion = '1.0'
src/types/provider.ts:export const ProviderIdSchema = z.enum(['openai', 'anthropic', 'ollama', 'azure'])
src/types/provider.ts:export type ProviderId = z.infer<typeof ProviderIdSchema>
src/types/provider.ts:export const ModelCapabilitiesSchema = z.object({
src/types/provider.ts:export type ModelCapabilities = z.infer<typeof ModelCapabilitiesSchema>
src/types/provider.ts:export const ModelSchema = z.object({
src/types/provider.ts:export type Model = z.infer<typeof ModelSchema>
src/types/provider.ts:export const ProviderConfigSchema = z.object({
src/types/provider.ts:export type ProviderConfig = z.infer<typeof ProviderConfigSchema>
src/types/provider.ts:export const MessageRoleSchema = z.enum(['system', 'user', 'assistant', 'tool'])
src/types/provider.ts:export type MessageRole = z.infer<typeof MessageRoleSchema>
src/types/provider.ts:export const CompletionMessageSchema = z.object({
src/types/provider.ts:export type CompletionMessage = z.infer<typeof CompletionMessageSchema>
src/types/provider.ts:export const AnthropicOptionsSchema = z.object({
src/types/provider.ts:export type AnthropicOptions = z.infer<typeof AnthropicOptionsSchema>
src/types/provider.ts:export const CompletionRequestSchema = z.object({
src/types/provider.ts:export type CompletionRequest = z.infer<typeof CompletionRequestSchema>
src/types/provider.ts:export const ToolCallSchema = z.object({
src/types/provider.ts:export type ToolCall = z.infer<typeof ToolCallSchema>
src/types/provider.ts:export const CompletionChunkSchema = z.object({
src/types/provider.ts:export type CompletionChunk = z.infer<typeof CompletionChunkSchema>
src/types/provider.ts:export const ValidationResultSchema = z.object({
src/types/provider.ts:export type ValidationResult = z.infer<typeof ValidationResultSchema>
src/types/provider.ts:export const ProviderErrorTypeSchema = z.enum([
src/types/provider.ts:export type ProviderErrorType = z.infer<typeof ProviderErrorTypeSchema>
src/types/provider.ts:export class ProviderError extends Error {
src/types/gpt-extensions.ts:export const GPTVersionSchema = z.object({
src/types/gpt-extensions.ts:export type GPTVersion = z.infer<typeof GPTVersionSchema>
src/types/gpt-extensions.ts:export interface GPTVersionDB {
src/types/gpt-extensions.ts:export const GPTFolderSchema = z.object({
src/types/gpt-extensions.ts:export type GPTFolder = z.infer<typeof GPTFolderSchema>
src/types/gpt-extensions.ts:export interface GPTFolderDB {
src/types/gpt-extensions.ts:export interface FolderTreeNode {
src/types/gpt-extensions.ts:export const MAX_FOLDER_DEPTH = 3
src/types/gpt-extensions.ts:export const MAX_VERSIONS_PER_GPT = 20
src/types/gpt-extensions.ts:export const AUTO_SAVE_DEBOUNCE_MS = 2000
src/types/gpt-extensions.ts:export const SyncEventType = {
src/types/gpt-extensions.ts:export type SyncEventType = (typeof SyncEventType)[keyof typeof SyncEventType]
src/types/gpt-extensions.ts:export interface SyncEvent {
src/types/gpt-extensions.ts:export interface DeleteResult {
src/contexts/storage-context.tsx:export interface StorageContextType {
src/contexts/storage-context.tsx:export const StorageContext = createContext<StorageContextType | undefined>(undefined)
src/contexts/mcp-context.tsx:export interface MCPContextType {
src/contexts/mcp-context.tsx:export const MCPContext = createContext<MCPContextType | undefined>(undefined)
src/contexts/mcp-context.tsx:export function MCPProvider({children}: MCPProviderProps) {
src/contexts/conversation-context.tsx:export type BulkAction = 'pin' | 'unpin' | 'archive' | 'unarchive' | 'delete'
src/contexts/conversation-context.tsx:export interface GetConversationsOptions {
src/contexts/conversation-context.tsx:export interface ConversationContextType {
src/contexts/conversation-context.tsx:export const ConversationContext = createContext<ConversationContextType | undefined>(undefined)
src/contexts/storage-provider.tsx:export function StorageProvider({children}: StorageProviderProps) {
src/contexts/conversation-provider.tsx:export function ConversationProvider({children}: ConversationProviderProps) {
src/contexts/ai-provider-context.tsx:export const AIProviderContext = createContext<AIProviderContextValue | null>(null)
src/contexts/ai-provider-context.tsx:export function AIProvider({children}: AIProviderProps) {
src/contexts/ai-provider-context.tsx:export function useAIProvider(): AIProviderContextValue {
src/contexts/session-context.tsx:export interface SessionContextValue {
src/contexts/session-context.tsx:export const SessionContext = createContext<SessionContextValue | null>(null)
src/contexts/session-context.tsx:export function SessionProvider({children}: SessionProviderProps) {
src/config/site.ts:export type SiteConfig = typeof siteConfig
src/config/site.ts:export const siteConfig = {
src/components/user-gpt-card.tsx:export interface UserGPTCardProps {
src/components/user-gpt-card.tsx:export const UserGPTCard: FC<UserGPTCardProps> = ({gpt, isLoading = false, error = null}) => {
src/components/ollama-model-card.tsx:export function OllamaModelCard({model, isSelected, onSelect, onDelete}: OllamaModelCardProps) {
src/components/navbar.tsx:export const Navbar = () => {
src/components/settings/appearance-settings.tsx:export function AppearanceSettings() {
src/components/settings/mcp-settings.tsx:export function MCPSettings() {
src/components/settings/ollama-settings.tsx:export function OllamaSettings() {
src/components/settings/provider-settings.tsx:export function ProviderSettings() {
src/components/settings/data-settings.tsx:export function DataSettings() {
src/components/settings/anthropic-settings.tsx:export function AnthropicSettings() {
src/components/settings/api-settings.tsx:export function APISettings() {
src/components/gpt-editor-tabs/vector-knowledge.tsx:export function VectorKnowledge({files, vectorStores, onCreateVectorStore, onDeleteVectorStore}: VectorKnowledgeProps) {
src/components/gpt-editor-tabs/general-tab.tsx:export function GeneralTab({gpt, onUpdate, errors, handleFieldValidation, hasFieldSuccess}: GeneralTabProps) {
src/components/gpt-editor-tabs/tools-tab.tsx:export function ToolsTab({gpt, onUpdate, errors}: ToolsTabProps) {
src/components/gpt-editor-tabs/advanced-settings-tab.tsx:export function AdvancedSettingsTab({gpt, onUpdate}: AdvancedSettingsTabProps) {
src/components/gpt-editor-tabs/knowledge-tab.tsx:export function KnowledgeTab({
src/components/archive-dialog.tsx:export function ArchiveDialog({gpt, mode, isOpen, onConfirm, onCancel, isLoading = false}: ArchiveDialogProps) {
src/components/create-folder-modal.tsx:export function CreateFolderModal({isOpen, onClose, onFolderCreated, parentFolderId}: CreateFolderModalProps) {
src/components/card.tsx:export interface CardProps {
src/components/card.tsx:export const Card: FC<CardProps> = ({
src/components/forms/form-field-wrapper.tsx:export function FormFieldWrapper({
src/components/export-dialog.tsx:export function ExportDialog({isOpen, onClose, conversation, onExport}: ExportDialogProps) {
src/components/chat/chat-interface.tsx:export function ChatInterface({
src/components/chat/message-bubble.tsx:export function MessageBubble({
src/components/chat/chat-input.tsx:export function ChatInput({onSendMessage, isDisabled, placeholder = 'Type a message...'}: ChatInputProps) {
src/components/chat/sidebar-content.tsx:export function SidebarContent({
src/components/import-dialog.tsx:export function ImportDialog({isOpen, onClose, onValidate, onImport}: ImportDialogProps) {
src/components/capabilities-configuration.tsx:export function CapabilitiesConfiguration({capabilities, onCapabilityChange}: CapabilitiesConfigurationProps) {
src/components/passphrase-modal.tsx:export type PassphraseModalMode = 'setup' | 'unlock' | 'change'
src/components/passphrase-modal.tsx:export interface PassphraseModalProps {
src/components/passphrase-modal.tsx:export function PassphraseModal({mode, isOpen, onClose, onSuccess}: PassphraseModalProps) {
src/components/conversation-search.tsx:export function ConversationSearch({
src/components/gpt-library.tsx:export function GPTLibrary({onSelectGPT, onEditGPT, onCreateGPT, folderId = null}: GPTLibraryProps) {
src/components/mcp/mcp-tool-call-visualization.tsx:export function MCPToolCallVisualization({toolCall, serverName, onRetry}: MCPToolCallVisualizationProps) {
src/components/mcp/mcp-server-card.tsx:export function MCPServerCard({server, onEdit, onDelete, onViewTools}: MCPServerCardProps) {
src/components/mcp/mcp-tool-explorer.tsx:export function MCPToolExplorer({serverId}: MCPToolExplorerProps) {
src/components/mcp/mcp-server-form.tsx:export function MCPServerForm({isOpen, onClose, onSave, initialConfig}: MCPServerFormProps) {
src/components/docs/api-reference.tsx:export function ApiReference() {
src/components/docs/doc-layout.tsx:export function DocLayout({children, sidebar}: DocLayoutProps) {
src/components/docs/agent-tutorial.tsx:export function AgentTutorial() {
src/components/docs/docs-sidebar.tsx:export function DocsSidebar() {
src/components/docs/interactive-notebook.tsx:export function InteractiveNotebook({initialCells = DEFAULT_CELLS, onExecute}: InteractiveNotebookProps) {
src/components/docs/docs-index.tsx:export function DocsIndex() {
src/components/docs/getting-started.tsx:export function GettingStarted() {
src/components/gpt-export-dialog.tsx:export function GPTExportDialog({isOpen, onClose, gpt, gpts, onExport, isBulkExport = false}: GPTExportDialogProps) {
src/components/session-warning.tsx:export interface SessionWarningProps {
src/components/session-warning.tsx:export function SessionWarning({className}: SessionWarningProps) {
src/components/knowledge-configuration.tsx:export function KnowledgeConfiguration({
src/components/footer.tsx:export const Footer: FC = () => {
src/components/tools-configuration.tsx:export function ToolsConfiguration({tools, errors, onAddTool, onRemoveTool, onToolChange}: ToolsConfigurationProps) {
src/components/version-history-panel.tsx:export function VersionHistoryPanel({gptId, isOpen, onClose, onRestore}: VersionHistoryPanelProps) {
src/components/layouts/default-layout.tsx:export function DefaultLayout({children, className, maxWidth = 'xl'}: DefaultLayoutProps) {
src/components/layouts/full-height-layout.tsx:export function FullHeightLayout({children, className}: FullHeightLayoutProps) {
src/components/layouts/sidebar-layout.tsx:export function SidebarLayout({children, sidebar, sidebarWidth = 'w-64', className}: SidebarLayoutProps) {
src/components/feature-card.tsx:export const FeatureCard: FC<FeatureCardProps> = ({
src/components/conversation-list.tsx:export function ConversationList({
src/components/file-upload/constants.ts:export const ACCEPTED_FILE_TYPES = {
src/components/file-upload/constants.ts:export type AcceptedFileType = keyof typeof ACCEPTED_FILE_TYPES
src/components/file-upload/constants.ts:export const DEFAULT_ALLOWED_TYPES = Object.values(ACCEPTED_FILE_TYPES)
src/components/file-upload/file-upload.tsx:export function FileUpload({
src/components/backup-restore-panel.tsx:export function BackupRestorePanel({
src/components/theme-switch.tsx:export const ThemeSwitch: FC = () => {
src/components/ollama-model-manager.tsx:export function OllamaModelManager() {
src/components/empty-states/no-providers-prompt.tsx:export function NoProvidersPrompt() {
src/components/conflict-resolution-panel.tsx:export function ConflictResolutionPanel({conflicts, resolutions, onResolutionChange}: ConflictResolutionPanelProps) {
src/components/folder-sidebar.tsx:export function FolderSidebar({selectedFolderId, onFolderSelect, onCreateFolder}: FolderSidebarProps) {
src/hooks/use-session.ts:export function useSession(): SessionContextValue {
src/hooks/use-session.ts:export function useSessionStatus() {
src/hooks/use-session.ts:export function useSecretAccess() {
src/hooks/use-session.ts:export function usePassphraseManagement() {
src/hooks/use-storage-quota.ts:export interface StorageQuotaResult {
src/hooks/use-storage-quota.ts:export function useStorageQuota(): StorageQuotaResult {
src/hooks/use-auto-save.ts:export interface AutoSaveState {
src/hooks/use-auto-save.ts:export interface UseAutoSaveOptions<T> {
src/hooks/use-auto-save.ts:export interface UseAutoSaveReturn<T> extends AutoSaveState {
src/hooks/use-auto-save.ts:export function useAutoSave<T>(
src/hooks/use-ollama-status.ts:export interface OllamaStatusResult {
src/hooks/use-ollama-status.ts:export interface UseOllamaStatusOptions {
src/hooks/use-ollama-status.ts:export function isHttpsToLocalhostScenario(ollamaUrl: string): boolean {
src/hooks/use-ollama-status.ts:export function useOllamaStatus(options: UseOllamaStatusOptions = {}): OllamaStatusResult {
src/hooks/use-ollama-status.ts:export function getOllamaBaseUrl(): string {
src/hooks/use-intersection-observer.ts:export interface UseIntersectionObserverOptions {
src/hooks/use-intersection-observer.ts:export function useIntersectionObserver<T extends Element = HTMLDivElement>(
src/hooks/use-conversation-context.ts:export function useConversationContext() {
src/hooks/use-reduced-motion.ts:export function useReducedMotion(): boolean {
src/hooks/use-mcp.ts:export function useMCP(): MCPContextType {
src/hooks/use-mcp.ts:export function useMCPConnectionStatus(serverId: string): ConnectionStatus {
src/hooks/use-mcp.ts:export function useMCPTools(serverId: string) {
src/hooks/use-mcp.ts:export function useMCPResources(serverId: string) {
src/hooks/use-mcp.ts:export function useMCPPrompts(serverId: string) {
src/hooks/use-mcp.ts:export function useEnabledMCPServers() {
src/hooks/use-mcp.ts:export function useConnectedMCPServers() {
src/hooks/use-mcp.ts:export function useAllConnectedTools() {
src/hooks/use-mcp.ts:export function useHasMCPServers() {
src/hooks/use-mcp.ts:export function useActiveToolCalls() {
src/hooks/use-gpt-validation.ts:export function useGPTValidation() {
src/hooks/use-openai-service.ts:export function useOpenAIService(): CreateOpenAIService {
src/hooks/use-storage.ts:export function useStorage(): StorageContextType {
src/lib/crypto.ts:export const PBKDF2_ITERATIONS = 100_000
src/lib/crypto.ts:export const KEY_LENGTH = 256
src/lib/crypto.ts:export const SALT_LENGTH = 16
src/lib/crypto.ts:export const IV_LENGTH = 12
src/lib/crypto.ts:export const PASSPHRASE_CHECK_VALUE = 'passphrase_verified'
src/lib/crypto.ts:export interface EncryptedData {
src/lib/crypto.ts:export function isWebCryptoAvailable(): boolean {
src/lib/crypto.ts:export function generateSalt(): Uint8Array<ArrayBuffer> {
src/lib/crypto.ts:export function generateIV(): Uint8Array<ArrayBuffer> {
src/lib/crypto.ts:export function arrayBufferToBase64(buffer: ArrayBuffer): string {
src/lib/crypto.ts:export function base64ToArrayBuffer(base64: string): ArrayBuffer {
src/lib/crypto.ts:export function uint8ArrayToBase64(array: Uint8Array<ArrayBuffer>): string {
src/lib/crypto.ts:export function base64ToUint8Array(base64: string): Uint8Array<ArrayBuffer> {
src/lib/database.ts:export interface ModelSettings {
src/lib/database.ts:export interface MCPToolDB {
src/lib/database.ts:export interface GPTKnowledgeDB {
src/lib/database.ts:export interface CapabilitiesDB {
src/lib/database.ts:export interface GPTConfigurationDB {
src/lib/database.ts:export interface ConversationDB {
src/lib/database.ts:export interface MessageMetadata {
src/lib/database.ts:export interface MessageDB {
src/lib/database.ts:export interface KnowledgeFileDB {
src/lib/database.ts:export interface EncryptedSecretDB {
src/lib/database.ts:export interface UserSettingDB {
src/lib/database.ts:export interface GPTVersionDB {
src/lib/database.ts:export interface GPTFolderDB {
src/lib/database.ts:export interface CachedURLDB {
src/lib/database.ts:export interface TextSnippetDB {
src/lib/database.ts:export class GPTDatabase extends Dexie {
src/lib/database.ts:export const db = new GPTDatabase()
src/lib/database.ts:export function toISOString(date: Date): string {
src/lib/database.ts:export function fromISOString(isoString: string): Date {
src/lib/database.ts:export function nowISO(): string {
src/lib/database.ts:export function isIndexedDBAvailable(): boolean {
src/lib/database.ts:export function closeDatabase(): void {
src/lib/design-system.ts:export function cn(...inputs: ClassValue[]) {
src/lib/design-system.ts:export const ds = {
src/lib/design-system.ts:export const responsive = {
src/lib/design-system.ts:export const theme = {
src/lib/design-system.ts:export const compose = {
src/lib/design-system.ts:export const variants = {
src/lib/design-system.ts:export type Size = (typeof variants.size)[number]
src/lib/design-system.ts:export type Color = (typeof variants.color)[number]
src/lib/design-system.ts:export type Variant = (typeof variants.variant)[number]
src/lib/design-system.ts:export type Radius = (typeof variants.radius)[number]
src/lib/design-system.ts:export const heroui = {
src/pages/backup-restore-page.tsx:export function BackupRestorePage() {
src/pages/home-page.tsx:export function HomePage() {
src/pages/settings-page.tsx:export function SettingsPage() {
src/pages/gpt-showcase-page.tsx:export function GPTShowcasePage() {
src/pages/gpt-test-page.tsx:export function GPTTestPage() {
src/pages/oauth-callback-page.tsx:export function OAuthCallbackPage() {
src/pages/gpt-editor-page.tsx:export function GPTEditorPage() {
src/services/folder-service.ts:export class FolderServiceError extends Error {
src/services/folder-service.ts:export class FolderService {
src/services/import-service.ts:export type ImportFileType = 'gpt' | 'conversation' | 'bulk' | 'backup' | 'unknown'
src/services/import-service.ts:export interface DetectedImport {
src/services/migration.ts:export interface MigrationResult {
src/services/migration.ts:export function needsMigration(): boolean {
src/services/migration.ts:export function clearMigrationFlag(): void {
src/services/providers/azure-provider.ts:export class AzureProvider extends BaseLLMProvider {
src/services/providers/ollama-provider.ts:export class OllamaProvider extends BaseLLMProvider {
src/services/providers/ollama-provider.ts:export function getOllamaProvider(): OllamaProvider {
src/services/providers/ollama-provider.ts:export function resetOllamaProviderForTesting(): void {
src/services/providers/ollama-provider.ts:export function clearOllamaModelCacheForTesting(provider: OllamaProvider): void {
src/services/providers/openai-provider.ts:export class OpenAIProvider extends BaseLLMProvider {
src/services/providers/openai-provider.ts:export function getOpenAIProvider(): OpenAIProvider {
src/services/providers/openai-provider.ts:export function resetOpenAIProviderForTesting(): void {
src/services/providers/anthropic-provider.ts:export class AnthropicProvider extends BaseLLMProvider {
src/services/providers/anthropic-provider.ts:export function getAnthropicProvider(): AnthropicProvider {
src/services/providers/anthropic-provider.ts:export function resetAnthropicProviderForTesting(): void {
src/services/providers/index.ts:export type {
src/services/providers/provider-registry.ts:export function getProviderRegistry(): ProviderRegistryImpl {
src/services/providers/provider-registry.ts:export function resetProviderRegistryForTesting(): void {
src/services/providers/provider-registry.ts:export type ProviderRegistry = ProviderRegistryImpl
src/services/conversation-export-service.ts:export const ExportFormatSchema = z.enum(['json', 'markdown'])
src/services/conversation-export-service.ts:export type ExportFormat = z.infer<typeof ExportFormatSchema>
src/services/conversation-export-service.ts:export const ExportOptionsSchema = z.object({
src/services/conversation-export-service.ts:export type ExportOptions = z.infer<typeof ExportOptionsSchema>
src/services/conversation-export-service.ts:export class ConversationExportService {
src/services/conversation-export-service.ts:export const conversationExportService = new ConversationExportService()
src/services/storage.ts:export class StorageError extends Error {
src/services/storage.ts:export interface StorageEstimate {
src/services/storage.ts:export interface StorageChangeEvent {
src/services/storage.ts:export interface StorageWarning {
src/services/storage.ts:export interface GetConversationsOptions {
src/services/storage.ts:export class IndexedDBStorageService {
src/services/openai-service.ts:export type CreateOpenAIService = ReturnType<typeof createOpenAIService>
src/services/openai-service.ts:export const openAIService = createOpenAIService()
src/services/openai-service.ts:export default createOpenAIService
src/services/conversation-search-service.ts:export interface SearchMatch {
src/services/conversation-search-service.ts:export interface SearchResult {
src/services/conversation-search-service.ts:export class ConversationSearchService {
src/services/conversation-search-service.ts:export const conversationSearchService = new ConversationSearchService()
src/services/cross-tab-sync.ts:export class CrossTabSyncService {
src/services/cross-tab-sync.ts:export function getCrossTabSyncService(): CrossTabSyncService {
src/services/cross-tab-sync.ts:export function destroyCrossTabSyncService(): void {
src/services/knowledge-service.ts:export class KnowledgeService {
src/services/knowledge-service.ts:export const knowledgeService = new KnowledgeService()
src/services/session.ts:export type SessionStatus = 'locked' | 'unlocking' | 'unlocked' | 'timing_out'
src/services/session.ts:export interface SessionState {
src/services/session.ts:export const SessionConfigSchema = z.object({
src/services/session.ts:export type SessionConfig = z.infer<typeof SessionConfigSchema>
src/services/session.ts:export interface SessionManager {
src/services/session.ts:export function getSessionManager(): SessionManager {
src/services/session.ts:export function resetSessionManagerForTesting(): void {
src/services/version-history.ts:export class VersionHistoryError extends Error {
src/services/version-history.ts:export class VersionHistoryService {
src/services/mcp-oauth-provider.ts:export class MCPBrowserOAuthProvider implements OAuthClientProvider {
src/services/mcp-oauth-provider.ts:export function getOAuthFlowServerId(): string | null {
src/services/mcp-oauth-provider.ts:export function clearOAuthFlowState(): void {
src/services/encryption.ts:export const PassphraseSchema = z.string().min(8, 'Passphrase must be at least 8 characters')
src/services/encryption.ts:export type ProviderType = 'openai' | 'anthropic' | 'azure' | 'ollama'
src/services/encryption.ts:export class EncryptionError extends Error {
src/services/encryption.ts:export interface EncryptionService {
src/services/encryption.ts:export function getEncryptionService(): EncryptionService {
src/services/encryption.ts:export function resetEncryptionServiceForTesting(): void {
src/services/mcp-client-service.ts:export type ConnectionStatus = 'disconnected' | 'connecting' | 'connected' | 'error'
src/services/mcp-client-service.ts:export interface MCPConnection {
src/services/mcp-client-service.ts:export interface MCPDiscoveredCapabilities {
src/services/mcp-client-service.ts:export interface MCPToolCallResult {
src/services/mcp-client-service.ts:export interface MCPClientService {
src/services/mcp-client-service.ts:export function getMCPClientService(): MCPClientService {
src/services/mcp-client-service.ts:export function resetMCPClientServiceForTesting(): void {
src/providers.tsx:export interface ProvidersProps {
src/providers.tsx:export const Providers = ({children}: ProvidersProps): React.ReactElement => {
